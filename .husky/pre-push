#!/bin/sh

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo "${BLUE}ğŸš€ Running pre-push validations...${NC}"

# 1. Check if we're pushing to main/develop branches
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "develop" ]; then
  echo "${YELLOW}âš ï¸  Pushing to protected branch: $CURRENT_BRANCH${NC}"
  echo "${YELLOW}  Make sure all quality checks have passed!${NC}"
fi

# 2. Run comprehensive quality checks
echo "${BLUE}  â†’ Running comprehensive quality checks...${NC}"
if ! pnpm quality:quick; then
  echo "${RED}âŒ Quick quality checks failed!${NC}"
  echo "${YELLOW}  Run 'pnpm quality' for detailed analysis${NC}"
  exit 1
fi

# 3. Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
  echo "${YELLOW}âš ï¸  You have uncommitted changes${NC}"
  echo "${YELLOW}  Consider committing them before pushing${NC}"
fi

# 4. Check if branch is up to date
echo "${BLUE}  â†’ Checking if branch is up to date...${NC}"
git fetch origin
LOCAL=$(git rev-parse @)
REMOTE=$(git rev-parse @{u})
BASE=$(git merge-base @ @{u})

if [ $LOCAL = $REMOTE ]; then
  echo "${GREEN}âœ“ Branch is up to date${NC}"
elif [ $LOCAL = $BASE ]; then
  echo "${YELLOW}âš ï¸  Your branch is behind remote${NC}"
  echo "${YELLOW}  Consider pulling latest changes first${NC}"
  read -p "Continue anyway? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "${RED}Push cancelled${NC}"
    exit 1
  fi
elif [ $REMOTE = $BASE ]; then
  echo "${GREEN}âœ“ Your branch is ahead of remote${NC}"
else
  echo "${YELLOW}âš ï¸  Your branch has diverged from remote${NC}"
  echo "${YELLOW}  Consider rebasing or merging${NC}"
  read -p "Continue anyway? (y/N): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "${RED}Push cancelled${NC}"
    exit 1
  fi
fi

# 5. Check for critical TODOs in production code
echo "${BLUE}  â†’ Checking for critical TODOs...${NC}"
CRITICAL_TODOS=$(git diff origin/$CURRENT_BRANCH..HEAD --name-only | xargs grep -l -E 'TODO|FIXME|HACK|XXX' 2>/dev/null | grep -v -E '\.(md|txt)$' || true)
if [ -n "$CRITICAL_TODOS" ]; then
  echo "${YELLOW}âš ï¸  Found TODO/FIXME comments in changed files:${NC}"
  echo "$CRITICAL_TODOS" | sed 's/^/    /'
  echo "${YELLOW}  Consider resolving these before pushing${NC}"
fi

# 6. Run tests for changed files (if any)
echo "${BLUE}  â†’ Checking for test changes...${NC}"
CHANGED_FILES=$(git diff origin/$CURRENT_BRANCH..HEAD --name-only)
CHANGED_TEST_FILES=$(echo "$CHANGED_FILES" | grep -E '\.(test|spec)\.(ts|tsx|js|jsx|py)$' || true)
CHANGED_SOURCE_FILES=$(echo "$CHANGED_FILES" | grep -E '\.(ts|tsx|js|jsx|py)$' | grep -v -E '\.(test|spec)\.' || true)

if [ -n "$CHANGED_TEST_FILES" ]; then
  echo "${BLUE}  â†’ Running tests for changed test files...${NC}"
  if ! pnpm test:unit; then
    echo "${RED}âŒ Tests failed!${NC}"
    exit 1
  fi
fi

# 7. Check if we need to run full test suite
if [ -n "$CHANGED_SOURCE_FILES" ]; then
  echo "${BLUE}  â†’ Source files changed, checking test coverage...${NC}"
  if [ ! -d "apps/web/coverage" ] || [ ! -d "apps/api/htmlcov" ]; then
    echo "${YELLOW}âš ï¸  No coverage reports found${NC}"
    echo "${YELLOW}  Consider running 'pnpm test:coverage' before pushing${NC}"
  fi
fi

# 8. Security check
echo "${BLUE}  â†’ Running security scan...${NC}"
if command -v gitleaks &> /dev/null; then
  if ! gitleaks detect --source . --config .gitleaks.toml; then
    echo "${RED}âŒ Security scan failed! Potential secrets detected.${NC}"
    exit 1
  fi
else
  echo "${YELLOW}âš ï¸  Gitleaks not installed, skipping security scan${NC}"
fi

# 9. Final validation
echo "${BLUE}  â†’ Final validation...${NC}"
if ! pnpm build; then
  echo "${RED}âŒ Build failed!${NC}"
  exit 1
fi

echo "${GREEN}âœ“ All pre-push checks passed!${NC}"
echo "${GREEN}ğŸš€ Ready to push!${NC}"
